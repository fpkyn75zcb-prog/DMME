<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat – DM Me</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="chat-container">
    <div id="messageArea" class="message-area"></div>
    <form id="chatForm" class="chat-form" autocomplete="off">
      <input id="messageInput" class="message-input" type="text" placeholder="Type a message..." required autofocus>
      <button type="submit" class="send-button">Send</button>
    </form>
  </div>

  <script>
    // Chat application with shared storage and 24‑hour message expiration
    (function () {
      // Replace this with the bucket ID you create at https://kvdb.io (must be public/no secret)
      const BUCKET_ID = 'REPLACE_WITH_YOUR_BUCKET_ID';
      // Prefix for message keys; each message becomes a separate key
      const MESSAGE_PREFIX = 'msg_';
      // Message TTL in seconds (24 hours)
      const MESSAGE_TTL = 86400;

      // Assign a simple numeric ID to each user using localStorage. IDs persist across sessions.
      const userIdKey = 'dm-me-user-id';
      let userId = localStorage.getItem(userIdKey);
      if (!userId) {
        userId = Math.floor(1000 + Math.random() * 9000).toString();
        localStorage.setItem(userIdKey, userId);
      }

      // DOM references
      const messageArea = document.getElementById('messageArea');
      const messageInput = document.getElementById('messageInput');
      const chatForm = document.getElementById('chatForm');

      // Append a message to the message area
      function appendMessage(msg, playSound) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message');
        if (msg.user === userId) {
          messageDiv.classList.add('my-message');
        } else {
          messageDiv.classList.add('their-message');
        }
        const userSpan = document.createElement('span');
        userSpan.classList.add('user-id');
        userSpan.textContent = 'User ' + msg.user;
        const textSpan = document.createElement('span');
        textSpan.classList.add('message-text');
        textSpan.textContent = msg.text;
        messageDiv.appendChild(userSpan);
        messageDiv.appendChild(textSpan);
        messageArea.appendChild(messageDiv);
        if (playSound) {
          beep();
        }
      }

      // Scroll to bottom of message area
      function scrollToBottom() {
        messageArea.scrollTop = messageArea.scrollHeight;
      }

      // Simple beep for notifications
      function beep() {
        try {
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
          oscillator.connect(gainNode);
          gainNode.connect(audioCtx.destination);
          oscillator.start();
          gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
          oscillator.stop(audioCtx.currentTime + 0.15);
        } catch (e) {
          // ignore audio errors
        }
      }

      // Fetch all messages from KVdb and display them
      async function loadMessages() {
        if (!BUCKET_ID || BUCKET_ID.indexOf('REPLACE_WITH') === 0) {
          // If bucket ID hasn't been set, do nothing
          return;
        }
        try {
          const url = `https://kvdb.io/${BUCKET_ID}/?values=true&format=json&prefix=${MESSAGE_PREFIX}`;
          const res = await fetch(url);
          if (!res.ok) return;
          const data = await res.json();
          // data is array of [key, value]
          const messages = [];
          const now = Date.now();
          data.forEach(([key, value]) => {
            try {
              const msg = typeof value === 'string' ? JSON.parse(value) : value;
              // Filter out messages older than 24 hours
              if (now - msg.timestamp < MESSAGE_TTL * 1000) {
                messages.push(msg);
              }
            } catch (e) {
              // ignore invalid JSON
            }
          });
          // Sort messages by timestamp
          messages.sort((a, b) => a.timestamp - b.timestamp);
          // Clear existing messages and append
          messageArea.innerHTML = '';
          messages.forEach(msg => appendMessage(msg, false));
          scrollToBottom();
        } catch (e) {
          console.error('Failed to load messages', e);
        }
      }

      // Send message to KVdb
      async function sendMessage(text) {
        if (!BUCKET_ID || BUCKET_ID.indexOf('REPLACE_WITH') === 0) {
          alert('Chat storage is not configured. Please set BUCKET_ID in chat.html.');
          return;
        }
        const timestamp = Date.now();
        const message = { user: userId, text: text, timestamp: timestamp };
        const key = `${MESSAGE_PREFIX}${timestamp}_${Math.floor(Math.random() * 100000)}`;
        try {
          await fetch(`https://kvdb.io/${BUCKET_ID}/${key}?ttl=${MESSAGE_TTL}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(message)
          });
        } catch (e) {
          console.error('Failed to send message', e);
        }
      }

      // Handle form submission
      chatForm.addEventListener('submit', function (event) {
        event.preventDefault();
        const text = messageInput.value.trim();
        if (!text) return;
        const localMsg = { user: userId, text: text, timestamp: Date.now() };
        appendMessage(localMsg, true);
        sendMessage(text);
        messageInput.value = '';
        scrollToBottom();
      });

      // Periodically fetch messages every 3 seconds for real‑time sync
      setInterval(loadMessages, 3000);
      // Initial load
      loadMessages();
    })();
  </script>
</body>
</html>